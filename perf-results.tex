% How is the ASP based solver performing?

The \clingo{} solver performance given a logic program depends
on a number of factors. First, the number of facts in a specific concretization. Second,
the configuration and various optimization parameters passed to the solver. 

The solving process consists of four stages: \emph{setup}, \emph{load}, 
\emph{ground}, and \emph{solve}. The first two are preliminary phases and the other two 
perform the actual solve. Specifically, the setup phase generates the facts for the given
spec, whereas the load phase loads the main logic program (i.e., the rules of the software 
model) as a resource into the solver. The grounding phase is the first part of the actual
solve, it turns the facts and first-order logic rules into propositional logic. Once we
have a grounded program, we can run the last phase, which is the full solve in \clingo{}.

We instrumented the solving code such that we obtained time measurements for each one
of the phases and the total time for the whole process.


\subsection{Solve timings for all packages}

In this section we examine the solving times for all the packages. First, we focus on
the relation between the solving times and the number of dependencies for each package.

\input{figures/deps_quartz_fig.tex}

\input{figures/deps_lassen_fig.tex}

Figures~\ref{fig:deps_quartz} and~\ref{fig:deps_lassen} show the grounding, solve, and full solving (i.e., involving all the stages) times for all the packages on Quartz and Lassen, respectively. Load times, as one would expect, were not affected by the number of packages. Also, the setup times are the same order of magnitude as ground times and do not depend on \clingo{}'s performance so they were ommitted in favor of showing times that are directly dependent on \clingo{}. We used the \clingo{}'s "tweety" configuration and "usc,one" optimization strategy for running the solving process. Further below we explore the differences in solving times between these different strategies.

We can see from the figures that the time increases as the number of dependent packages increases. This is because increased number of dependencies leads to a larger number of facts and a bigger logic program overall.

Figures~\ref{fig:deps_quartz} and~\ref{fig:deps_lassen} also show that there are two major clusters in the execution times. The clusters are separated by a gap in the dependencies. One cluster contains packages with less than 200 dependencies, whereas, the other major cluster contains packages with more than 400 dependencies. 

% The gap occurs because of dependency on \emph{cmake}, which itself depends cumulatively on more than 400 packages.

Besides dependencies another set of factors that influences the execution times are \clingo{} parameters. Specifically, \clingo{} defines six configuration presets: \emph{frumpy}, \emph{jumpy}, \emph{tweety}, \emph{trendy}, \emph{crafty}, and \emph{handy}. Each preset sets numerous low level parameters that control different aspects of the solver. In our performance study, we specifically focus on three configurations: \emph{tweety} -- geared towards typical ASP programs, \emph{trendy} -- geared towards industrial problems, and \emph{handy} -- geared towards large problems.

\input{figures/cumulative_quartz_fig.tex}

\input{figures/cumulative_lassen_fig.tex}

Figures~\ref{fig:cdf_quartz} and~\ref{fig:cdf_lassen} show the cumulative distribution of the solve times under \emph{tweety}, \emph{trendy}, and \emph{handy} configurations on Quartz and Lassen machines, respectively. The vast majority of packages are fully solved in under 25 seconds on both machines. We can also see that there is no difference in ground times between the different configurations. This suggests that most low level parameters that are tweaked by each configuration control the actual solving phase. The figures cleary indicate that \emph{tweety} perform better than the other configurations we benchmarked. This is, therefore, the default configuraion used in the concretization process. 

- other properties?
- --single-shot vs. no single-shot?
- different tactics?

\subsection{Solve timings for all packages with reuse}
- scaling repo size

\input{figures/e4s_cache_quartz_fig.tex}

\input{figures/e4s_cache_lassen_fig.tex}


