%-------------------------------------------------------------------------------
\section{Answer Set Programming}
%-------------------------------------------------------------------------------
\label{sec:asp}

Answer Set Programming (ASP) is a form of logical programming that allows for first-order logic (variables and quantification) in addition to boolean operators.
While the input language for ASP is derived from Prolog~\cite{baral_2003} syntax and shares many syntax features, ASP solvers are not directly related to Prolog and do not share its solving algorithm.
We will focus on the language for Clingo as a de-facto standard for ASP; there is also an additional standard for the ASP input language, ASP-Core-2.
Existing solvers, including clingo, tend to lag behind the standard in implementing syntax.

\subsection{ASP Syntax}

The basic unit of an ASP program is a ``term''.
A \textit{term} can be a boolean atom or a function whose arguments may be further terms.
A term followed by a period (.) is called a ``fact''.
The following is a simple program snippet that does nothing but describe some facts.

\begin{minted}[fontsize=\small, bgcolor=bg]{prolog}
  optimize_for_reuse.
  node("hdf5").
  depends_on("hdf5", "mpi").
\end{minted}

In addition to facts, ASP programs contain rules.
Rules allow ASP to derive additional facts.
ASP rules contain a head and a body, separated by \texttt{:-}.
The \texttt{:-} can be read as ``if'' --- the head (left side) is true if the body (right side) is true.
Terms in the body of a rule can also be preceded by the keyword ``not'' to imply the head based on their negation.
Logical ``and'' is represented by a comma in the rule body, and logicl ``or'' is represented by repeating the head with a different rule body.
Additionally, Capitalized words are variables.
Rules are instantiated with all possible substitutions for variables.

\begin{minted}[fontsize=\small, bgcolor=bg]{prolog}
  optimize_for_reuse.
  node("hdf5").
  depends_on("hdf5", "mpi").
  node(Dependency) :- node(Package), depends_on(Package, Dependency).
\end{minted}

The rule here translates roughly to ``If a package is in the graph and it depends on another package, that package must be in the graph''.

Two particular types of rules are important to understand the power of ASP: \textit{integrity constraints} and \textit{choice rules}.

Answer Set Programming gets its name from the set of possible answers which satisfy the constraints of the program.
ASP solvers focus on understanding the constraints on this space.
Integrity constraints allow the programmer to rule out swatch of the answer set space by specifying conditions not to allow.
In AnsProlog, these are represented by a headless rule.

\begin{minted}[fontsize=\small, bgcolor=bg]{prolog}
  optimize_for_reuse.
  node("hdf5").
  depends_on("hdf5", "mpi").
  node(Dependency) :- node(Package), depends_on(Package, Dependency).
  :- depends_on(Package, Package).
\end{minted}

Here our integrity constraint says ``A package cannot depend on itself''.

Choice rules, on the other hand, give the solver freedom to choose from possible options.
A choice rule is (optionally) constrained on either side to specify the minimum (left) and maximum (right) number of choices the solver can select.

\begin{minted}[fontsize=\small, bgcolor=bg]{prolog}
  optimize_for_reuse.
  node("hdf5").
  depends_on("hdf5", "mpi").
  node(Dependency) :- node(Package), depends_on(Package, Dependency).
  :- depends_on(Package, Package).

  possible_version("hdf5", "1.13.1").
  possible_version("hdf5", "1.12.1").
  1 { version(Package, Version) : possible_version(Package, Version) } 1 :- node(Package).
\end{minted}

The choice rule on the last line means ``If a package is in the graph, choose single version for it from among the possible versions for that package.''
The ${a:b}$ syntax here has the same meaning as in formal set theory; it denotes the set of all $a$ such that $b$ is true.
The addition of the numerals on either side instruct the solver to select an appropriate number of elements from that set, if the body condition holds.
Choice rules allow the solver substantial freedom to create facts, within the specified constraints, that satisfy other constraint of the program or maximize optimization criteria.

In addition to constraints on the solution space, ASP allows optimization criteria.
Optimization criteria allow the solver to return a single answer set from the among all valid answer sets, and guarantee that the chosen answer set minimizes or maximizes some criteria.
There are often many valid solutions to a dependency resolution query, but only the optimal solution is relevant once we find it.

\begin{minted}[fontsize=\small, bgcolor=bg]{prolog}
  optimize_for_reuse.
  node("hdf5").
  depends_on("hdf5", "mpi").
  node(Dependency) :- node(Package), depends_on(Package, Dependency).
  :- depends_on(Package, Package).

  possible_version("hdf5", "1.13.1").
  possible_version("hdf5", "1.12.1").
  1 { version(Package, Version) : possible_version(Package, Version) } 1 :- node(Package).

  #minimize{ Weight@3,Package,Version : version_weight(Package, Version, Weight)}.
\end{minted}

This optimization constraint says ``I prefer (at priority 3) solutions that minimize the sum of the weights of the package versions, for all packages and versions.''
A detailed discussion of the syntax for optimization is beyond the scope of this paper; for our purposes, it suffices to know that complex optimization across a variety of criteria at discrete priorities is possible in ASP.

Our small and very incomplete program here already shows the power of ASP.
In a SAT solver, the programmer would need to write out explicitly the rule for deriving dependency nodes from dependent nodes for every possible pair of packages.
Even worse, our choice rule for selecting versions would need to be written out for every combination of package and version, and an enormous combination of logical operators constructed to ensure that for any group of versions \texttt{$a_1, ..., a_n$}, one of the constructions \texttt{$a_i$} and not any \texttt{$a_j$} for all $i\neq{j}$.
Writing out the facts of our small program in SAT is hard enough, and we haven't even discussed implementing optimization criteria in boolean logic.
In ASP, though, it appears reasonably straightforward and is legible to future maintainers of our code.

\subsection{ASP Solvers}

ASP solvers search the input program for stable models, also known as \textit{answer sets}.
An answer set is a set of true atoms that can be deduced from the inputs, where every rule is satisfied.
ASP solvers utilize a huge variety of methods to find answer sets.
We will focus on the structure of the \texttt{clingo} solver that we use in \spack.

\paragraph{Clingo}

The \textit{clingo} solver consists of two components: the grounder (\textit{gringo}) and the solver (\textit{clasp}).
\textit{Clasp} uses a CDCL SAT algorithm and can also do MaxSAT-style optimizations.
\textit{Gringo} ``grounds'' the problem by translating the first-order logic of ASP into a MaxSAT problem that can be understood by the CDCL algorithm.

While the internals of \textit{clasp} and \textit{gringo} are outside the scope of this work, it is important to understand that it guarantees completeness of the algorithm.
There are no set of inputs for which \textit{clingo} will return a false negative (claim the rules are incompatible if they are not) and optimal solutions returned by \textit{clingo} are guaranteed to be optimal.

%% TODO: This could probably use some work here
