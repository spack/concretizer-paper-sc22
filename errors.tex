Generating useful debug messages and error output from logic solvers can be challenging.
Solvers algorithms are sufficiently complex that an ``unsatisfiable'' end-state sometimes cannot be easily mapped to particular offending constraints.
One common method for error messages in solvers are subset-minimal unsatisfiable cores.
Subset-minimal unsatisfiable cores are unsatisfiable subsets of solution for which removing any element from the overall problem results in a satisfiable problem.
In a nearly trivial case, the clingo program

\begin{verbatim}
foo(x)
foo(y)

: foo(A), foo(B), A != B.
\end{verbatim}

will yield a subset-minimal unsatisfiable core of

$$ {foo(x), foo(y)} $$

assuming it is configured appropriately to allow each fact in the core.

Configuring clingo to generate subset-minimal unsatisfiable cores is non-trivial.
Clingo only generates unsatisfiable cores when using the ``usc'' optimization strategy.
It also does not naturally generate subset-minimal unsatisfiable cores; the unsatisfiable core returned by clingo can be quite large.
Mitigating the size of the cores, clingo cores only contain facts that are presented to the solver as ``assumptions'' and allowed as choice points for the algorithm.
Including the assumptions as choice points in the algorithm means that there is a tradeoff between the comprehensiveness of the generated cores and the runtime of the program, as increased choice leads directly to increased runtime.

Generating a subset-minimal core from the non-minimal cores generated by clingo is possible.
It requires iterative solves for each element of the core, which can be prohibitive for larger core sizes.
The algorithm is in pythonic psuedocode below.

\begin{verbatim}
solution, core = solve(assumptions=assumptions)

if core:
    min_core = core[:]
    for fact in core:
        min_core.remove(fact)
        solution, core = solve(
        if solution:
            min_core.append(fact)

    raise UnsatisfiableError(min_core)
...
\end{verbatim}

This algorithm can be very slow.
Iterative solves are not as expensive as the initial solve, potentially by an order of magnitute, but core sizes can be very large

Using a naive approach in which every fact from the program is an assumption in clingo, simple \spack problems like concretizing ``hwloc'' can generate cores with over 30,000 elements.
In one case we tested, over 30,000 elements were generated for a core when the subset-minimal core contained just two elements.
Minimizing cores of this size is infeasible, with minimization times over 40 minutes for a problem that solves in tens of seconds.

An additional weakness of the naive approach is that rules in clingo cannot be assumptions.
Therefore the subset-minimal unsatisfiable core is a collection of facts, with no information about which integrity constraints of the problem are violated by those facts.
That information can be difficult to glean without expert knowledge.

In response to those weaknesses of the naive approach, we devised a more lightweight approach for \spack.
We added a function to our clingo program with the signature \texttt{error/1.}.
Every integrity constraint in the concretizer program contains a term that is \texttt{error(msg)}, where ``msg'' is a string describing the purpose of the integrity constraint.
The error terms are the only facts in the program which are given as constraints to clingo.
This leads to unsatisfiable cores small enough to be minimized in a reasonable time \textemdash there are 16 assumptions in the program, which is the worst-case for the iterative solves necessary for core minimization.
In practice, this can be done in a small fraction of the original solve time.
Satisfiable solves for the ``hwloc'' package take on the order of ten seconds, and core minimization adds around another second.
Performance numbers will be discussed in more detail in the ``Performance Results'' section.

Future work will revolve around how much of the detail of the naive approach can be reintegrated with the error messages without degrading performance.
This will include work on batching tests in the minimization algorithm.
Because clingo's unsatisfiable cores tend to be very large compared to the subset-minimal cores for this problem, we may be able to drastically reduce the number of necessary tests by attempting to remove some fraction of the entire core at once, only testing in smaller granularity when we encounter a portion of the core containing an element of the minimal subset.
